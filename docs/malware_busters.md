
## Malware Busters!

You are presented with an unknown and odd binary in a compromised environment.

Your job is to analyze the binary as best you can. Your analysis should include:

* Describe the actions performed by the malware.

* Find the C2 server the malware communicates with.

* Decrypt the malware's C2 protocol.

By following these steps you will find the hidden flag to complete the challenge.

Good luck!

---

## Useful Linux Analysis Commands

### Basic file triage
```bash
file buu
```
*Shows basic info about the binary (type, architecture, etc).*

### Extract readable strings (if 'strings' is not installed)
```bash
LC_ALL=C grep -aEo '[[:print:]]{4,}' buu > buu.strings
```
*Extracts printable strings (length ‚â• 4) from the binary for manual review.*

### Search for C2/network indicators in strings
```bash
egrep -in 'https?://|([0-9]{1,3}\.){3}[0-9]{1,3}\b|[a-z0-9.-]+\.[a-z]{2,}\b' buu.strings | head -n 200
egrep -in ':(80|443|53|8080|8443|9001|31337)\b|port|host|c2|beacon|callback|connect|socket' buu.strings | head -n 200
```
*Finds URLs, IPs, domains, and common C2/network keywords in extracted strings.*

### Search for filesystem/behavior hints
```bash
egrep -in '/etc/|/proc/|/dev/|/tmp|/var/|\.ssh|authorized_keys|cron|crontab|systemd|\.config|\.local|bashrc|profile|passwd|shadow|sudoers|\.service' buu.strings | head -n 250
```
*Looks for references to important files, directories, and system artifacts.*

### Search for crypto/encoding hints
```bash
egrep -in 'base64|xor|rc4|aes|chacha|rsa|sha|hmac|encrypt|decrypt|key|iv|nonce|salt|zlib|gzip' buu.strings | head -n 200
```
*Finds mentions of cryptography, encoding, and compression routines.*

### Check for tool availability
```bash
for x in tcpdump strace ltrace ss netstat lsof gdb; do command -v $x 2>/dev/null && echo "have $x"; done
```
*Lists which analysis tools are installed and available on your system.*

### Dynamic analysis with strace
```bash
strace -f -s 200 -o trace.log ./buu 2>/dev/null
```
*Runs the binary under strace, logging all system calls (including child processes) to trace.log.*

Explanation (line-by-line):

- strace: the tool that intercepts and records system calls made by a process.
- -f: follow child processes (trace forks/execs) so we capture actions from spawned processes too.
- -s 200: set the maximum string size to print to 200 bytes (prevents truncation of larger strings).
- -o trace.log: write strace output to the file `trace.log` instead of stdout.
- ./buu: the program to execute under strace.
- 2>/dev/null: redirect strace's stderr to /dev/null to suppress non-essential output.

If you want to focus on file operations (useful for locating reads of `/tmp/.X11/cnf`):
```bash
strace -f -s 200 -o files.log -e trace=file ./buu 2>/dev/null
grep -nF '/tmp/.X11/cnf' files.log
```
*`strace -e trace=file` records only file-related syscalls; the grep finds occurrences of the config blob path in the output.*

Explanation (line-by-line):

- -e trace=file: restrict tracing to file-related syscalls (open, read, stat, etc.). This reduces noise and speeds up analysis.
- files.log: output file where the file-trace will be written.
- grep -nF '/tmp/.X11/cnf' files.log: search `files.log` for literal occurrences of the config path and print line numbers (-n) for quick location.

### Search strace output for key actions
```bash
grep -E 'openat|connect|getaddrinfo|write|execve' trace.log | head -n 200
```
*Filters the strace log for file access, network connections, and process execution events.*

---

### Analyzing strace Output: What Did the Binary Actually Do?

After running `strace -f -s 200 -o trace.log ./buu 2>/dev/null`, you'll have a comprehensive log of all system calls. Here's how to systematically analyze it to understand the binary's behavior:

#### 1. View the Full Trace (Overview)
```bash
less trace.log
# or with line numbers
cat -n trace.log | less
```

#### 2. Get a Summary of All Syscalls Used
```bash
# Count unique syscalls to see what the binary does
awk -F'(' '{print $1}' trace.log | sort | uniq -c | sort -rn | head -30
```
*Shows which syscalls are most frequently used ‚Äî lots of `read`/`write` = file or network I/O; lots of `mmap` = memory allocation; `connect`/`socket` = network activity.*

#### 3. Trace File Operations (What Files Were Accessed?)
```bash
# All file opens (successful)
grep 'openat.*= [0-9]' trace.log

# All file opens (including failures)
grep 'openat' trace.log

# What files were read
grep -E 'openat|read\(' trace.log | head -100

# Files that were written to
grep -E 'openat.*O_WRONLY|openat.*O_RDWR|write\(' trace.log

# Check for sensitive file access
grep -E 'openat.*(passwd|shadow|ssh|authorized_keys|\.config|cron|history)' trace.log
```

#### 4. Trace Network Activity (C2 Communication)
```bash
# Socket creation
grep 'socket(' trace.log

# DNS lookups
grep -E 'getaddrinfo|gethostbyname' trace.log

# Network connections (IP + port)
grep 'connect(' trace.log

# Data sent over network
grep -E 'send\(|sendto\(|write\([3-9]' trace.log

# Data received from network
grep -E 'recv\(|recvfrom\(|read\([3-9]' trace.log
```

#### 5. Trace Process Execution (Did It Spawn Other Commands?)
```bash
# Commands executed
grep 'execve' trace.log

# Fork/clone (child process creation)
grep -E 'fork|clone|vfork' trace.log

# What the spawned processes did
grep -E 'execve.*uname|execve.*whoami|execve.*id|execve.*cat' trace.log
```

#### 6. Trace Memory and Library Operations
```bash
# Shared libraries loaded
grep 'openat.*\.so' trace.log

# Memory mappings
grep 'mmap' trace.log | head -50

# Memory protection changes (could indicate unpacking)
grep 'mprotect' trace.log
```

#### 7. Timeline Analysis (What Happened in Order?)
```bash
# Add timestamps to trace
strace -f -s 200 -t -o trace_timed.log ./buu 2>/dev/null

# Or relative timestamps (time since start)
strace -f -s 200 -r -o trace_relative.log ./buu 2>/dev/null

# View with timestamps
head -100 trace_timed.log
```

#### 8. Filter by Specific System Call Categories
```bash
# File operations only
strace -f -s 200 -e trace=file -o files_only.log ./buu 2>/dev/null

# Network operations only
strace -f -s 200 -e trace=network -o network_only.log ./buu 2>/dev/null

# Process management only
strace -f -s 200 -e trace=process -o process_only.log ./buu 2>/dev/null

# Memory operations only
strace -f -s 200 -e trace=memory -o memory_only.log ./buu 2>/dev/null

# All I/O (file descriptors)
strace -f -s 200 -e trace=desc -o io_only.log ./buu 2>/dev/null
```

#### 9. Extract Actual Data Written/Read
```bash
# Show full data in hex (-x or -xx for all bytes)
strace -f -s 500 -x -o trace_hex.log ./buu 2>/dev/null

# Find strings being sent/received
grep -oP 'write\(\d+, "[^"]*"' trace.log
grep -oP 'read\(\d+, "[^"]*"' trace.log
```

#### 10. Common Patterns to Look For

| Pattern | What It Means |
|---------|---------------|
| `socket(AF_INET, SOCK_STREAM)` | TCP socket created |
| `socket(AF_INET, SOCK_DGRAM)` | UDP socket (possibly DNS) |
| `connect(3, {sa_family=AF_INET, sin_port=htons(443)...})` | Outbound HTTPS connection |
| `execve("/bin/sh", ["/bin/sh", "-c", ...])` | Shell command execution |
| `openat(AT_FDCWD, "/etc/passwd", O_RDONLY)` | Reading passwd file |
| `openat(..., O_WRONLY|O_CREAT)` | Creating/writing a file |
| `unlink("/path/to/file")` | Deleting a file |
| `mprotect(..., PROT_READ|PROT_EXEC)` | Making memory executable (unpacking?) |

#### 11. Quick One-Liner: Full Behavior Summary
```bash
# Get a quick summary of what the binary did
echo "=== Files Accessed ===" && grep 'openat' trace.log | grep -v ENOENT | cut -d'"' -f2 | sort -u && \
echo "=== Network Connections ===" && grep 'connect' trace.log | grep -v EINPROGRESS && \
echo "=== Commands Executed ===" && grep 'execve' trace.log | cut -d'"' -f2 | sort -u && \
echo "=== DNS Lookups ===" && grep 'getaddrinfo' trace.log
```

#### 12. Combine with ltrace for Library Calls
```bash
# ltrace shows library function calls (complements strace)
ltrace -f -s 200 -o ltrace.log ./buu 2>/dev/null

# Look for crypto functions
grep -E 'crypt|ssl|aes|encrypt|decrypt|base64' ltrace.log

# Look for string operations
grep -E 'strcmp|strstr|strcpy|sprintf' ltrace.log
```

#### Example: Reconstructing Malware Behavior from strace

Given a trace like this:
```
openat(AT_FDCWD, "/tmp/.X11/cnf", O_RDONLY) = 3
read(3, "\x89\x50\x4e\x47..."..., 144) = 144
close(3)
socket(AF_INET, SOCK_STREAM, 0) = 4
connect(4, {sa_family=AF_INET, sin_port=htons(443), sin_addr=inet_addr("3.151.15.69")}) = 0
write(4, "GET /beacon HTTP/1.1\r\n"..., 256) = 256
read(4, "HTTP/1.1 200 OK..."..., 4096) = 1024
```

**Interpretation:**
1. Binary reads 144 bytes from `/tmp/.X11/cnf` (config/key material)
2. Creates a TCP socket
3. Connects to `3.151.15.69:443` (HTTPS)
4. Sends an HTTP request (beacon)
5. Receives response from C2 server

---

### UPX unpacking attempt
```bash
command -v upx
upx -d buu -o buu_unpacked
```
*Checks if UPX is installed and tries to unpack the binary (if packed with UPX).*

### Test for UPX packing
```bash
upx -t buu
```
*Tests if the binary is packed with UPX. Result: `NotPackedException: not packed by UPX` ‚Äî binary is NOT UPX-packed (or headers are tampered).*

### View binary header (look for packer signatures)
```bash
hexdump -C buu | head -n 100
hexdump -C buu | grep -i upx
```
*Inspects raw bytes for packer magic like `UPX!` or section names `UPX0`/`UPX1`.*

### UPX walkthrough (reference)
https://www.youtube.com/watch?v=0jVikfySiII
*Useful UPX unpacking walkthrough to review later.*

### UPX detection (correct commands and explanation)
If you want to check whether `buu` is UPX-packed, use the commands below. I fixed the typos from the previous attempt and added fallbacks if some tools are missing.

```bash
# 1) Portable printable-strings extraction (no `strings` required)
LC_ALL=C grep -aEo '[[:print:]]{4,}' buu > buu.strings

# 2) Quick search for UPX signatures in extracted strings
egrep -in 'UPX|UPX!' buu.strings || echo "no UPX strings found"

# 3) If `strings` is available, a faster direct check
command -v strings >/dev/null && strings -a -n 6 buu | egrep -in 'UPX|UPX!' || echo "strings not available or no UPX strings"

# 4) Check ELF section names (looks for UPX0/UPX1)
command -v readelf >/dev/null && readelf -S buu 2>/dev/null | egrep 'UPX0|UPX1' || echo "no UPX sections found or readelf missing"

# 5) Raw hex/ASCII scan for UPX magic in the file header/body (fallbacks if hexdump missing)
if command -v hexdump >/dev/null; then
  hexdump -C buu | head -n 200 | egrep -i 'UPX!|UPX0|UPX1' || echo "no UPX magic found in first 200 lines"
elif command -v od >/dev/null; then
  od -An -tx1 -v buu | head -n 200
  echo "(use the output above to visually inspect for UPX strings)"
else
  echo "neither hexdump nor od is available to inspect raw bytes"
fi
```

Explanation (short):
- `grep -aEo '[[:print:]]{4,}'`: extracts printable runs (like `strings`) without requiring the `strings` utility.
- `egrep -in 'UPX|UPX!'`: searches for common UPX markers (case-insensitive) in extracted strings.
- `strings -a -n 6`: standard `strings` usage, show printable sequences length ‚â•6.
- `readelf -S`: lists ELF section headers; UPX commonly creates `UPX0`/`UPX1` sections.
- `hexdump -C` / `od`: view raw bytes to find `UPX!` magic or embedded header text.

Interpreting the pasted output you provided:

- `bash: strings: command not found` ‚Äî the `strings` utility is not installed on your system. Use the `grep` extraction above instead (it does the same job).
- `no UPX sections found` ‚Äî `readelf` did not find `UPX0/UPX1` sections. That usually means the file is not packed by standard UPX sections, although UPX can be tampered with.
- `bash: hexdump: command not found` ‚Äî your system lacks `hexdump`; use `od` as a fallback or install `hexdump`/`bsdmainutils`.
- The lines that look like `7541:6'Upx` and `25448:$Id: UPX 3.96 ...` suggest the string `UPX` exists somewhere in the file (possibly a leftover or a benign attribution string), but that alone doesn't guarantee the binary is packed: it could be an embedded message or documentation text inside the file.

Next steps if you see UPX strings but `upx -t` reports NotPackedException:

- The UPX header may be stripped or modified. Use a disassembler (radare2/Cutter/Ghidra) to inspect for UPX unpacking stubs or compressed code sections.
- Run entropy analysis (binwalk -E or `ent`) to find high-entropy regions that suggest packing/encryption.
- If you want, I can add a small bash script `tools/check_upx.sh` to the repo that runs all checks and prints a short verdict.

---

## Challenge Answers

### ‚úÖ Question 1: Describe the actions performed by the malware

The malware performs the following actions when executed:

| Stage | Action | Details | Evidence (strace) |
|-------|--------|---------|-------------------|
| **1** | **Host Reconnaissance** | Executes system commands to gather host info | `execve("/usr/bin/uname", ["uname", "-n"])` |
| | | Collects hostname via `uname -n` | Returns machine hostname |
| | | Collects username via `whoami` | `execve("/usr/bin/whoami", ["whoami"])` |
| | | Collects user/group info via `id` | `execve("/usr/bin/id", ["id"])` |
| **2** | **Local Account Enumeration** | Reads `/etc/passwd` to enumerate local accounts | `openat(AT_FDCWD, "/etc/passwd", O_RDONLY)` |
| | | Observed output: `root:x:0:0:root:/root:/bin/bash` | |
| **3** | **Config/Key Loading** | Opens hidden config file `/tmp/.X11/cnf` | `openat(AT_FDCWD, "/tmp/.X11/cnf", O_RDONLY)` |
| | | Reads 144 bytes of binary key/seed material | `read(3, "\x89\x50..."..., 144) = 144` |
| **4** | **DNS Resolution Setup** | Reads system DNS configuration | `openat(..., "/etc/nsswitch.conf", O_RDONLY)` |
| | | | `openat(..., "/etc/resolv.conf", O_RDONLY)` |
| **5** | **C2 Beaconing** | Creates TCP socket | `socket(AF_INET, SOCK_STREAM, 0)` |
| | | Resolves C2 domain via DNS (using 1.1.1.1) | `connect(..., sin_port=htons(53), "1.1.1.1")` |
| | | Connects to C2 server over HTTPS (port 443) | `connect(..., sin_port=htons(443), "3.151.15.69")` |
| | | Initiates TLS handshake with SNI | ClientHello with server name indication |

**Summary:** This is an **info-stealer/beacon malware** that:
1. Gathers system reconnaissance (hostname, user, groups, local accounts)
2. Loads encryption key material from a hidden file
3. Beacons out to an AWS Lambda C2 server over HTTPS
4. Likely exfiltrates collected data encrypted with the key from `/tmp/.X11/cnf`

---

### ‚úÖ Question 2: Find the C2 server the malware communicates with

| Indicator | Value | How Found |
|-----------|-------|-----------|
| **C2 Hostname** | `wehiy6oj3hpaud3yske7nrt5xu0lcovj.lambda-url.us-east-2.on.aws` | TLS SNI header + DNS query in strace/tcpdump |
| **C2 IP Address** | `3.151.15.69` | `connect()` syscall in strace |
| **C2 Port** | `443` (HTTPS) | `sin_port=htons(443)` in connect() |
| **DNS Resolver Used** | `1.1.1.1:53` (Cloudflare) | Hardcoded DNS, not system resolver |
| **Protocol** | TLS 1.2/1.3 over TCP | ALPN: `h2`, `http/1.1` |
| **Infrastructure** | AWS Lambda URL (us-east-2 region) | Domain pattern `.lambda-url.*.on.aws` |

**C2 Server:** `https://wehiy6oj3hpaud3yske7nrt5xu0lcovj.lambda-url.us-east-2.on.aws`

**Network Indicators of Compromise (IOCs):**
```
# Domain
wehiy6oj3hpaud3yske7nrt5xu0lcovj.lambda-url.us-east-2.on.aws

# IP (may change - serverless)
3.151.15.69

# DNS over Cloudflare (suspicious if not normal for environment)
1.1.1.1:53
```

---

### üîç Investigating the C2 Server

Once you've identified the C2 server, use these commands to gather more intel:

#### DNS Reconnaissance
```bash
# Resolve the domain
dig wehiy6oj3hpaud3yske7nrt5xu0lcovj.lambda-url.us-east-2.on.aws

# Get all DNS records
dig ANY wehiy6oj3hpaud3yske7nrt5xu0lcovj.lambda-url.us-east-2.on.aws

# Check with different resolvers
dig @8.8.8.8 wehiy6oj3hpaud3yske7nrt5xu0lcovj.lambda-url.us-east-2.on.aws
dig @1.1.1.1 wehiy6oj3hpaud3yske7nrt5xu0lcovj.lambda-url.us-east-2.on.aws

# Reverse DNS lookup on the IP
dig -x 3.151.15.69

# If dig not available, use host or nslookup
host wehiy6oj3hpaud3yske7nrt5xu0lcovj.lambda-url.us-east-2.on.aws
nslookup wehiy6oj3hpaud3yske7nrt5xu0lcovj.lambda-url.us-east-2.on.aws
```

#### Check if C2 is Alive
```bash
# Basic connectivity test
ping -c 3 3.151.15.69

# Check if port 443 is open
nc -zv 3.151.15.69 443
# or
timeout 5 bash -c 'cat < /dev/null > /dev/tcp/3.151.15.69/443' && echo "Port open" || echo "Port closed"

# Check TLS certificate info
echo | openssl s_client -connect 3.151.15.69:443 -servername wehiy6oj3hpaud3yske7nrt5xu0lcovj.lambda-url.us-east-2.on.aws 2>/dev/null | openssl x509 -noout -subject -issuer -dates

# Get full certificate chain
echo | openssl s_client -connect 3.151.15.69:443 -servername wehiy6oj3hpaud3yske7nrt5xu0lcovj.lambda-url.us-east-2.on.aws -showcerts 2>/dev/null
```

#### Probe the C2 Endpoint
```bash
# Simple GET request to see what it returns
curl -sk https://wehiy6oj3hpaud3yske7nrt5xu0lcovj.lambda-url.us-east-2.on.aws/

# With verbose output (see headers, TLS info)
curl -vsk https://wehiy6oj3hpaud3yske7nrt5xu0lcovj.lambda-url.us-east-2.on.aws/

# Check HTTP headers only
curl -skI https://wehiy6oj3hpaud3yske7nrt5xu0lcovj.lambda-url.us-east-2.on.aws/

# Try common C2 paths
curl -sk https://wehiy6oj3hpaud3yske7nrt5xu0lcovj.lambda-url.us-east-2.on.aws/beacon
curl -sk https://wehiy6oj3hpaud3yske7nrt5xu0lcovj.lambda-url.us-east-2.on.aws/api
curl -sk https://wehiy6oj3hpaud3yske7nrt5xu0lcovj.lambda-url.us-east-2.on.aws/c2
curl -sk https://wehiy6oj3hpaud3yske7nrt5xu0lcovj.lambda-url.us-east-2.on.aws/flag

# POST request (some C2s require POST)
curl -sk -X POST https://wehiy6oj3hpaud3yske7nrt5xu0lcovj.lambda-url.us-east-2.on.aws/

# With custom User-Agent (mimic the malware if known)
curl -sk -A "Mozilla/5.0" https://wehiy6oj3hpaud3yske7nrt5xu0lcovj.lambda-url.us-east-2.on.aws/
```

#### WHOIS & Infrastructure Intel
```bash
# WHOIS on the IP
whois 3.151.15.69

# Check IP geolocation and ASN
curl -s https://ipinfo.io/3.151.15.69

# Check if IP is known malicious (VirusTotal, AbuseIPDB)
# Manual check: https://www.virustotal.com/gui/ip-address/3.151.15.69
# Manual check: https://www.abuseipdb.com/check/3.151.15.69
```

#### Capture Traffic to/from C2
```bash
# Capture all traffic to the C2 IP
tcpdump -i any host 3.151.15.69 -w c2_traffic.pcap

# Capture DNS queries for the domain
tcpdump -i any port 53 -w dns_queries.pcap

# Live view of connections
watch -n 1 'ss -tnp | grep 3.151.15.69'
# or
netstat -tnp | grep 3.151.15.69
```

#### Check What the Malware Sends (Replay Attack)
```bash
# If you captured the exact request from strace/tcpdump, replay it:
# Example: if malware sends specific headers or data

# Using the key material from /tmp/.X11/cnf
hexdump -C /tmp/.X11/cnf
cat /tmp/.X11/cnf | base64  # encode to see the key

# Try sending the key as auth
curl -sk -H "Authorization: Bearer $(cat /tmp/.X11/cnf | base64)" \
  https://wehiy6oj3hpaud3yske7nrt5xu0lcovj.lambda-url.us-east-2.on.aws/

# Or as POST data
curl -sk -X POST --data-binary @/tmp/.X11/cnf \
  https://wehiy6oj3hpaud3yske7nrt5xu0lcovj.lambda-url.us-east-2.on.aws/
```

---

### üîì Question 3: Decrypt the malware's C2 protocol (IN PROGRESS)

#### What We Know

- Uses **TLS over TCP/443** to the Lambda URL.
- TLS ClientHello includes **SNI** set to the Lambda URL hostname.
- Advertises **ALPN** for `h2` and `http/1.1` ‚Äî application protocol is likely **HTTPS**.
- **Key material** is loaded from `/tmp/.X11/cnf` (144 bytes)
- Content inside TLS is encrypted; to decrypt we need to:
  - Capture plaintext before encryption (gdb hooks / function breaks), or
  - Reproduce client crypto using key material from `/tmp/.X11/cnf`, or
  - Query the endpoint directly and decode response format.

---

## Next Steps: Decrypt the C2 Protocol

To find the flag, we need to decrypt or intercept the C2 communication. The key material is likely in `/tmp/.X11/cnf`.

### 1. Use gdb to break on read of `/tmp/.X11/cnf`
```bash
gdb ./buu
```
Inside gdb:
```
break open
run
```
*Step through until you see `/tmp/.X11/cnf` being opened, then inspect the buffer after read.*

### 2. Dump the config/key blob
```bash
hexdump -C /tmp/.X11/cnf
```
*Shows the 144-byte key/seed material used by the malware.*

### 3. Trace where the blob is used
- Set breakpoints on crypto functions or XOR loops.
- Watch for the blob being used to transform outbound data.

### 4. Alternatively, intercept plaintext before TLS
- Use `LD_PRELOAD` hooks or `gdb` to break on `write`/`send` before encryption.

---

**Goal:** Locate how `/tmp/.X11/cnf` is used to encrypt/obfuscate C2 traffic, then decrypt to reveal the flag.




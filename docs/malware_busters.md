
## Malware Busters!

You are presented with an unknown and odd binary in a compromised environment.

Your job is to analyze the binary as best you can. Your analysis should include:

* Describe the actions performed by the malware.

* Find the C2 server the malware communicates with.

* Decrypt the malware's C2 protocol.

By following these steps you will find the hidden flag to complete the challenge.

Good luck!

---

## Useful Linux Analysis Commands

### Basic file triage
```bash
file buu
```
*Shows basic info about the binary (type, architecture, etc).*

### Extract readable strings (if 'strings' is not installed)
```bash
LC_ALL=C grep -aEo '[[:print:]]{4,}' buu > buu.strings
```
*Extracts printable strings (length ≥ 4) from the binary for manual review.*

### Search for C2/network indicators in strings
```bash
egrep -in 'https?://|([0-9]{1,3}\.){3}[0-9]{1,3}\b|[a-z0-9.-]+\.[a-z]{2,}\b' buu.strings | head -n 200
egrep -in ':(80|443|53|8080|8443|9001|31337)\b|port|host|c2|beacon|callback|connect|socket' buu.strings | head -n 200
```
*Finds URLs, IPs, domains, and common C2/network keywords in extracted strings.*

### Search for filesystem/behavior hints
```bash
egrep -in '/etc/|/proc/|/dev/|/tmp|/var/|\.ssh|authorized_keys|cron|crontab|systemd|\.config|\.local|bashrc|profile|passwd|shadow|sudoers|\.service' buu.strings | head -n 250
```
*Looks for references to important files, directories, and system artifacts.*

### Search for crypto/encoding hints
```bash
egrep -in 'base64|xor|rc4|aes|chacha|rsa|sha|hmac|encrypt|decrypt|key|iv|nonce|salt|zlib|gzip' buu.strings | head -n 200
```
*Finds mentions of cryptography, encoding, and compression routines.*

### Check for tool availability
```bash
for x in tcpdump strace ltrace ss netstat lsof gdb; do command -v $x 2>/dev/null && echo "have $x"; done
```
*Lists which analysis tools are installed and available on your system.*

### Dynamic analysis with strace
```bash
strace -f -s 200 -o trace.log ./buu 2>/dev/null
```
*Runs the binary under strace, logging all system calls (including child processes) to trace.log.*

Explanation (line-by-line):

- strace: the tool that intercepts and records system calls made by a process.
- -f: follow child processes (trace forks/execs) so we capture actions from spawned processes too.
- -s 200: set the maximum string size to print to 200 bytes (prevents truncation of larger strings).
- -o trace.log: write strace output to the file `trace.log` instead of stdout.
- ./buu: the program to execute under strace.
- 2>/dev/null: redirect strace's stderr to /dev/null to suppress non-essential output.

If you want to focus on file operations (useful for locating reads of `/tmp/.X11/cnf`):
```bash
strace -f -s 200 -o files.log -e trace=file ./buu 2>/dev/null
grep -nF '/tmp/.X11/cnf' files.log
```
*`strace -e trace=file` records only file-related syscalls; the grep finds occurrences of the config blob path in the output.*

Explanation (line-by-line):

- -e trace=file: restrict tracing to file-related syscalls (open, read, stat, etc.). This reduces noise and speeds up analysis.
- files.log: output file where the file-trace will be written.
- grep -nF '/tmp/.X11/cnf' files.log: search `files.log` for literal occurrences of the config path and print line numbers (-n) for quick location.

### Search strace output for key actions
```bash
grep -E 'openat|connect|getaddrinfo|write|execve' trace.log | head -n 200
```
*Filters the strace log for file access, network connections, and process execution events.*

### UPX unpacking attempt
```bash
command -v upx
upx -d buu -o buu_unpacked
```
*Checks if UPX is installed and tries to unpack the binary (if packed with UPX).*

### Test for UPX packing
```bash
upx -t buu
```
*Tests if the binary is packed with UPX. Result: `NotPackedException: not packed by UPX` — binary is NOT UPX-packed (or headers are tampered).*

### View binary header (look for packer signatures)
```bash
hexdump -C buu | head -n 100
hexdump -C buu | grep -i upx
```
*Inspects raw bytes for packer magic like `UPX!` or section names `UPX0`/`UPX1`.*

### UPX walkthrough (reference)
https://www.youtube.com/watch?v=0jVikfySiII
*Useful UPX unpacking walkthrough to review later.*

### UPX detection (correct commands and explanation)
If you want to check whether `buu` is UPX-packed, use the commands below. I fixed the typos from the previous attempt and added fallbacks if some tools are missing.

```bash
# 1) Portable printable-strings extraction (no `strings` required)
LC_ALL=C grep -aEo '[[:print:]]{4,}' buu > buu.strings

# 2) Quick search for UPX signatures in extracted strings
egrep -in 'UPX|UPX!' buu.strings || echo "no UPX strings found"

# 3) If `strings` is available, a faster direct check
command -v strings >/dev/null && strings -a -n 6 buu | egrep -in 'UPX|UPX!' || echo "strings not available or no UPX strings"

# 4) Check ELF section names (looks for UPX0/UPX1)
command -v readelf >/dev/null && readelf -S buu 2>/dev/null | egrep 'UPX0|UPX1' || echo "no UPX sections found or readelf missing"

# 5) Raw hex/ASCII scan for UPX magic in the file header/body (fallbacks if hexdump missing)
if command -v hexdump >/dev/null; then
  hexdump -C buu | head -n 200 | egrep -i 'UPX!|UPX0|UPX1' || echo "no UPX magic found in first 200 lines"
elif command -v od >/dev/null; then
  od -An -tx1 -v buu | head -n 200
  echo "(use the output above to visually inspect for UPX strings)"
else
  echo "neither hexdump nor od is available to inspect raw bytes"
fi
```

Explanation (short):
- `grep -aEo '[[:print:]]{4,}'`: extracts printable runs (like `strings`) without requiring the `strings` utility.
- `egrep -in 'UPX|UPX!'`: searches for common UPX markers (case-insensitive) in extracted strings.
- `strings -a -n 6`: standard `strings` usage, show printable sequences length ≥6.
- `readelf -S`: lists ELF section headers; UPX commonly creates `UPX0`/`UPX1` sections.
- `hexdump -C` / `od`: view raw bytes to find `UPX!` magic or embedded header text.

Interpreting the pasted output you provided:

- `bash: strings: command not found` — the `strings` utility is not installed on your system. Use the `grep` extraction above instead (it does the same job).
- `no UPX sections found` — `readelf` did not find `UPX0/UPX1` sections. That usually means the file is not packed by standard UPX sections, although UPX can be tampered with.
- `bash: hexdump: command not found` — your system lacks `hexdump`; use `od` as a fallback or install `hexdump`/`bsdmainutils`.
- The lines that look like `7541:6'Upx` and `25448:$Id: UPX 3.96 ...` suggest the string `UPX` exists somewhere in the file (possibly a leftover or a benign attribution string), but that alone doesn't guarantee the binary is packed: it could be an embedded message or documentation text inside the file.

Next steps if you see UPX strings but `upx -t` reports NotPackedException:

- The UPX header may be stripped or modified. Use a disassembler (radare2/Cutter/Ghidra) to inspect for UPX unpacking stubs or compressed code sections.
- Run entropy analysis (binwalk -E or `ent`) to find high-entropy regions that suggest packing/encryption.
- If you want, I can add a small bash script `tools/check_upx.sh` to the repo that runs all checks and prints a short verdict.

---

## Findings

### Actions performed by the malware

| Action | Details |
|--------|---------|
| **Host reconnaissance** | Executes `uname -n`, `whoami`, and `id` to collect hostname, username, UID/GID/groups. |
| **Local account enumeration** | Reads and prints `/etc/passwd` (observed: `root:x:0:0:root:/root:/bin/bash`). |
| **Uses local config/secret blob** | Opens `/tmp/.X11/cnf` (144 bytes, binary key/seed material). |
| **Name resolution + network beaconing** | Reads `/etc/nsswitch.conf` and `/etc/resolv.conf`, performs DNS lookups, connects outward. |

### C2 server

| Indicator | Value |
|-----------|-------|
| **C2 hostname (SNI + DNS)** | `wehiy6oj3hpaud3yske7nrt5xu0lcovj.lambda-url.us-east-2.on.aws` |
| **DNS resolver used** | `1.1.1.1:53` (Cloudflare) |
| **Observed C2 IP (HTTPS)** | `3.151.15.69:443` |
| **Other IPs probed** | Multiple AWS IPs and IPv6 addresses (some IPv6 fail with `EADDRNOTAVAIL`). |

### C2 protocol

- Uses **TLS over TCP/443** to the Lambda URL.
- TLS ClientHello includes **SNI** set to the Lambda URL hostname.
- Advertises **ALPN** for `h2` and `http/1.1` — application protocol is likely **HTTPS**.
- Content inside TLS is encrypted; to decrypt:
  - Capture plaintext before encryption (gdb hooks / function breaks), or
  - Reproduce client crypto using key material (likely `/tmp/.X11/cnf`), or
  - Query the endpoint directly and decode response format.

---

## Next Steps: Decrypt the C2 Protocol

To find the flag, we need to decrypt or intercept the C2 communication. The key material is likely in `/tmp/.X11/cnf`.

### 1. Use gdb to break on read of `/tmp/.X11/cnf`
```bash
gdb ./buu
```
Inside gdb:
```
break open
run
```
*Step through until you see `/tmp/.X11/cnf` being opened, then inspect the buffer after read.*

### 2. Dump the config/key blob
```bash
hexdump -C /tmp/.X11/cnf
```
*Shows the 144-byte key/seed material used by the malware.*

### 3. Trace where the blob is used
- Set breakpoints on crypto functions or XOR loops.
- Watch for the blob being used to transform outbound data.

### 4. Alternatively, intercept plaintext before TLS
- Use `LD_PRELOAD` hooks or `gdb` to break on `write`/`send` before encryption.

---

**Goal:** Locate how `/tmp/.X11/cnf` is used to encrypt/obfuscate C2 traffic, then decrypt to reveal the flag.



